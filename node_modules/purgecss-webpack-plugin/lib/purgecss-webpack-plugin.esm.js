import{existsSync as t}from"fs";import s from"path";import o,{defaultOptions as e}from"purgecss";import{ConcatSource as i}from"webpack-sources";const n=[".css",".scss",".styl",".sass",".less"];export default class{constructor(t){this.purgedStats={},this.options=t}apply(t){t.hooks.compilation.tap("PurgeCSS",this.initializePlugin.bind(this))}initializePlugin(s){s.hooks.additionalAssets.tapPromise("PurgeCSS",(()=>{const o="function"==typeof this.options.paths?this.options.paths():this.options.paths;return o.forEach((s=>{if(!t(s))throw new Error(`Path ${s} does not exist.`)})),this.runPluginHook(s,o)}))}async runPluginHook(t,r){const c=Object.entries(t.assets).filter((([t])=>function(t,o){const e=s.extname((i=t).includes("?")?i.split("?").slice(0,-1).join(""):i);var i;return o.includes(e)}(t,[".css"])));for(const s of t.chunks){const a=c.filter((([t])=>this.options.only?this.options.only.some((s=>t.includes(s))):Array.isArray(s.files)?s.files.includes(t):s.files.has(t)));for(const[s,c]of a){const a=r.filter((t=>!n.some((s=>t.endsWith(s))))),l={...e,...this.options,content:a,css:[{raw:c.source().toString()}]};"function"==typeof l.safelist&&(l.safelist=l.safelist()),"function"==typeof l.blocklist&&(l.blocklist=l.blocklist());const f=(await(new o).purge({content:l.content,css:l.css,defaultExtractor:l.defaultExtractor,extractors:l.extractors,fontFace:l.fontFace,keyframes:l.keyframes,output:l.output,rejected:l.rejected,variables:l.variables,safelist:l.safelist,blocklist:l.blocklist}))[0];f.rejected&&(this.purgedStats[s]=f.rejected),t.updateAsset(s,new i(f.css))}}}}
